% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/model.matrix.CBFM.R
\name{model.matrix.CBFM}
\alias{model.matrix.CBFM}
\title{Extract model matrices (otherwise known as design matrices) from a CBFM fit}
\usage{
\method{model.matrix}{CBFM}(object, zi = FALSE, ...)
}
\arguments{
\item{object}{An object of class \code{CBFM}.}

\item{zi}{For zero-inflated distributions, set this to \code{TRUE} if the model matrix associated with modeling the probabilities of zero-inflation is desired.}

\item{...}{Not used.}
}
\value{
A model matrix.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#stable}{\figure{lifecycle-stable.svg}{options: alt='[Stable]'}}}{\strong{[Stable]}}

Obtains the model matrix from a fitted \code{CBFM} object. This is especially useful when the fitted CBFM includes smoothing terms, say, in which case, the function will return the precise model matrix used.
}
\details{
Similar to how \code{\link[mgcv:model.matrix.gam]{mgcv::model.matrix.gam()}} works, it calls \code{\link[mgcv:predict.gam]{mgcv::predict.gam()}} with no \code{newdata} argument and \code{type = "lpmatrix"} in order to obtain the model matrix. Note this is the model matrix associated with the covariates i.e., based on arguments \code{object$formula}, and \strong{not} the basis functions.

For zero-inflated distributions, it can also obtain the model matrix associated with modeling the probabilities of zero-inflation.
}
\examples{
\donttest{
library(autoFRK)
library(FRK)
library(MASS)
library(mvabund)
library(mvtnorm)
library(ROCR)
library(sp)
library(RandomFields)
library(tidyverse)

##------------------------------
## **Example 1: Fitting a CBFM to spatial multivariate presence-absence data** 
## simulated from a spatial latent variable model
## Please note the data generation process (thus) differs from CBFM.
##------------------------------
set.seed(2021)
num_sites <- 500 # 500 (units) sites 
num_spp <- 50 # Number of species
num_X <- 4 # Number of regression slopes

spp_slopes <- matrix(runif(num_spp * num_X, -1, 1), nrow = num_spp)
spp_intercepts <- runif(num_spp, -2, 0)

# Simulate spatial coordinates and environmental covariate components
xy <- data.frame(x = runif(num_sites, 0, 5), y = runif(num_sites, 0, 5))
X <- rmvnorm(num_sites, mean = rep(0,4)) 
colnames(X) <- c("temp", "depth", "chla", "O2")
dat <- data.frame(xy, X)
mm <- model.matrix(~ temp + depth + chla + O2 - 1, data = dat) \%>\% 
scale \%>\% 
as.matrix

# Simulate latent variable component
true_lvs <- RFsimulate(model = RMexp(var=1, scale=2), 
x = xy$x, y = xy$y, n = 2)@data \%>\% 
as.matrix
spp_loadings <- matrix(runif(num_spp * 2, -1, 1), nrow = num_spp) 
set.seed(NULL)

# Simulate spatial multivariate abundance data (presence-absence)
eta <- tcrossprod(cbind(1,mm), cbind(spp_intercepts,spp_slopes)) + 
tcrossprod(true_lvs, spp_loadings)
simy <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = binomial()$linkinv(eta)), nrow = num_sites)
rm(X, mm, spp_loadings, true_lvs, xy, eta)


# Set up spatial basis functions for CBFM -- Most users will start here! 
num_basisfunctions <- 25 # Number of spatial basis functions to use
basisfunctions <- mrts(dat[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column

# Fit CBFM 
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy, formula = useformula, data = dat, 
B_space = basisfunctions, family = binomial(), control = list(trace = 1))

model.matrix(fitcbfm)
}

}
\seealso{
\code{\link[=CBFM]{CBFM()}} for fitting CBFMs, \code{\link[=fitted.CBFM]{fitted.CBFM()}} for extracting fitted values from a CBFM fit, \code{\link[=residuals.CBFM]{residuals.CBFM()}} for calculating various types of residuals, and \code{\link[=predict.CBFM]{predict.CBFM()}} for constructing predictions from a CBFM fit.
}
\author{
Francis K.C. Hui \href{mailto:fhui28@gmail.com}{fhui28@gmail.com}, Chris Haak
}
