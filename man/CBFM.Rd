% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/CBFM.R
\name{CBFM}
\alias{CBFM}
\title{Community-level basis function models (CBFMs)}
\usage{
CBFM(
  y,
  formula_X,
  data,
  B_space = NULL,
  B_time = NULL,
  B_spacetime = NULL,
  offset = NULL,
  ncores = NULL,
  family = stats::gaussian(),
  trial_size = 1,
  dofit = TRUE,
  stderrors = TRUE,
  select = FALSE,
  start_params = list(betas = NULL, basis_effects_mat = NULL, dispparam = NULL,
    powerparam = NULL, zeroinfl_prob = NULL),
  TMB_directories = list(cpp = system.file("executables", package = "CBFM"), compile =
    system.file("executables", package = "CBFM")),
  control = list(maxit = 1000, optim_lower = -5, optim_upper = 5, convergence_type =
    "parameters", tol = 1e-04, seed = NULL, trace = 0, ridge = 0),
  Sigma_control = list(rank = 5, maxit = 1000, tol = 1e-04, method = "LA", trace = 0),
  G_control = list(rank = 5, nugget_profile = seq(0.05, 0.95, by = 0.05), maxit = 1000,
    tol = 1e-04, method = "LA", trace = 0)
)
}
\arguments{
\item{y}{A response matrix, where each row corresponds to an observational unit i.e, a particular space-time coordinate, and each column corresponds to the species.}

\item{formula_X}{An object of class "formula", which represents a symbolic description of the model matrix to be created (based on using this argument along with the \code{data} argument). Note there should be nothing on the left hand side of the "~". Formulas based on generalized additive models or GAMs are permitted (at least, for the smoothing terms we have tried so far!); please see \code{\link[mgcv:formula.gam]{mgcv::formula.gam()}} and \code{\link[mgcv:s]{mgcv::s()}} for more details.}

\item{data}{A data frame containing covariate information, from which the model matrix is to be created (based on this argument along with the \code{formula_X} argument).}

\item{B_space}{An optional matrix of spatial basis functions to be included in the CBFM. One of \code{B_space}, \code{B_time}, or \code{B_spacetime} must be supplied. The basis function matrix may be sparse or dense in form; please see the details and examples later on for illustrations of how they can constructed.}

\item{B_time}{An optional of matrix of temporal basis functions to be included in the CBFM. One of \code{B_space}, \code{B_time}, or \code{B_spacetime} must be supplied. The basis function matrix may be sparse or dense in form; please see the details and examples later on for illustrations of how they can constructed.}

\item{B_spacetime}{An optional of matrix of spatio-temporal basis functions to be included in the CBFM e.g., formed from a tensor-product of spatial and temporal basis functions. One of \code{B_space}, \code{B_time}, or \code{B_spacetime} must be supplied. The basis function matrix may be sparse or dense in form; please see the details and examples later on for illustrations of how they can constructed.}

\item{offset}{A matrix of offset terms.}

\item{ncores}{To speed up fitting, parallelization can be performed, in which case this argument can be used to supply the number of cores to use in the parallelization. Defaults to \code{detectCores()-1}.}

\item{family}{a description of the response distribution to be used in the model, as specified by a family function. Please see details below for more information on the distributions currently permitted.}

\item{trial_size}{Trial sizes to use for binomial distribution. This can either equal a scalar or a matrix with the same dimension as \code{y}.}

\item{dofit}{Should the CBFM be fitted? If set to \code{FALSE}, then the function terminates (and return nothing) immediately after copying the C++ file to the compilation directory; please see the \code{TMB_directories} argument below.}

\item{stderrors}{Should standard errors of the estimates be calculated? This defaults to \code{TRUE}, but can be set of \code{FALSE} if only point estimations of the regression coefficients for the covariates and basis functions are desired. Please see details later on for more information on how standard errors are constructed.}

\item{select}{For cases where \code{formula_X} involves smoothing terms, setting this to \code{TRUE} adds an extra penalty to each smoothing term so that it can be penalized to zero i.e., null space penalization. Please see \code{\link[mgcv:gam.selection]{mgcv::gam.selection()}} and \code{\link[mgcv:step.gam]{mgcv::step.gam()}} for more details, noting that its implementation for the purposes of CBFM is a \emph{wee bit experimental}. Note also this argument has not effect on any parametric terms in the model i.e., it can not shrink parametric terms to zero.}

\item{start_params}{Starting values for the CBFM. If desired, then a list should be supplied, which must contain at least one the following terms:
\itemize{
\item{betas: }{A matrix of starting values for the species-specific regression coefficients related to the covariates, where the number of rows is equal to the number of species.}
\item{basis_effect_mat: }{A matrix of starting values for the species-specific regression coefficients related to the combined matrix of basis functions. Again, the number of rows is equal to the number of species, while the number of columns should equal to \code{ncol(B_space, B_time, B_spacetime)} (or whatever the supplied basis functions are).}
\item{dispparam: }{A vector of starting values for the species-specific dispersion parameters, to be used for distributions that require one.}
\item{powerparam: }{A vector of starting values for the species-specific power parameters, to be used for distributions that require one.}
\item{zeroinfl_prob: }{A vector of species-specific probabilities of zero-inflation, to be used for distributions that require one. }
}}

\item{TMB_directories}{A list with two elements, identifying the directory where TMB C++ file exists (\code{cpp}), and the directory where the corresponding compiled files to be placed (\code{compile}). Unless you really want to do some real mucking around, these should be left at their default i.e., the directory where the packages were installed locally. Please note a version of the C++ file will be copied to the \code{compile} directory.}

\item{control}{A list of parameters for controlling the fitting process for the "outer" PQL estimation part of the CBFM. This should be a list with the following arguments:
\itemize{
\item{maxit: }{The maximum number of iterations for the outer algorithm.}
\item{optim_lower/optim_upper: }{Upper and lower box constraints when updating regression coefficients related to the basis functions. Note no constraints are put in place when updating regression coefficients related to the covariates; this are controlled internally by \code{\link[mgcv:gam.control]{mgcv::gam.control()}} itself.}
\item{convergence_type: }{The type of means by which to assess convergence. The current options are "parameters" (default) which assess convergence based on the norm of the difference between estimated parameters from successive iterations, and "logLik", which assess convergence based on how close the ratio in the PQL value between successiveiterations is to one.}
\item{tol: }{The tolerance value to use when assessing convergence.}
\item{seed: }{The seed to use for the PQL algorithm. This is only applicable when the starting values are randomly generated, which be default should not be the case.}
\item{trace: }{If set to \code{TRUE} or \code{1}, then information at each iteration step of the outer algorithm will be printed. }
\item{ridge: }{A additional ridge parameter that can be included to act as a ridge penalty when estimating the regression coefficients related to the covariates.}
}}

\item{Sigma_control}{A list of parameters for controlling the fitting process for the "inner" estimation part of the CBFM pertaining to the community-level covariance matrices of the basis function regression coefficients. This should be a list with the following arguments:
\itemize{
\item{rank: }{The rank of the community-level covariance matrices of the basis function regression coefficients. This either equals to a scalar, or a vector with length equal to how many of \code{B_space/B_time/B_spacetime} are supplied. If it is a scalar, then it is assumed that the same rank is used for all the community-level covariance matrices. The ranks should be at least equal to 2, and not larger than the number of species. Please see details below for more information.}
\item{maxit: }{The maximum number of iterations for inner update of the community-level covariance matrices.}
\item{tol: }{The tolerance value to use when assessing convergence. Convergence for the inner algorithm is assessed based on the norm of the difference between estimated parameters from successive iterations.}
\item{method: }{The method by which to update the community-level covariance matrices. The current options are "LA" (default) which uses optimizing the Laplace approximated restricted maximum likelihood (REML), and "simple" which uses a fast large sample covariance update. The latter is \emph{much} faster than the former, but is much less accurate and we only recommend using it for pilot testing.}
\item{trace: }{If set to \code{TRUE} or \code{1}, then information at each iteration step of the inner algorithm will be printed.}
}}

\item{G_control}{A list of parameters for controlling the fitting process for the "inner" estimation part of the CBFM pertaining to the so-called baseline between-species correlation matrices of the basis function regression coefficients. This should be a list with the following arguments:
\itemize{
\item{rank}{The rank of the between-species correlation matrices of the basis function regression coefficients. This either equals to a scalar, or a vector with length equal to how many of \code{B_space/B_time/B_spacetime} are supplied. If it is a scalar, then it is assumed that the same rank is used for all the correlation matrices. The ranks should be at least equal to 2, and not larger than the number of species. Please see details below for more information.}
\item{nugget_profile: }{The sequence of values to try for calculating the nugget effect in each between-species correlation matrix. Please see details below for more information.}
\item{maxit: }{The maximum number of iterations for inner update of the community-level covariance matrices.}
\item{tol: }{The tolerance value to use when assessing convergence. Convergence for the inner algorithm is assessed based on the norm of the difference between estimated parameters from successive iterations.}
\item{method: }{The method by which to update the correlation matrices. The current options are "LA" (default) which uses optimizing the Laplace approximated restricted maximum likelihood (REML), and "simple" which uses a fast large sample covariance update. The latter is \emph{much} faster than the former, but is much less accurate and we only recommend using it for pilot testing.}
\item{trace: }{If set to \code{TRUE} or \code{1}, then information at each iteration step of the inner algorithm will be printed.}
}}
}
\value{
An object of class "CBFM" which includes the following components, not necessarily in the order below (and as appropriate):
\item{call: }{The matched function call.}
\item{family: }{The supplied response distribution i.e., family function, to be used in the model.}
\item{y, data, trial_size: }{The supplied response matrix, covariate information data frame, and trial size(s).}
\item{formula_X: }{The supplied symbolic description of the model matrix to be created.}
\item{B: }{The full matrix basis functions i.e., basically the result of \code{cbind(B_space, B_time, B_spacetime)}.}
\item{which_B_used: }{A vector of length three, indicating which of \code{B_space, B_time, B_spacetime} was supplied. For example \code{which_B_bused = c(1,0,0)} implies only \code{B_space} was supplied.}
\item{num_B_space: }{The number of spatial basis functions supplied i.e., \code{ncol(B_space)}.}
\item{num_B_time: }{The number of temporal basis functions supplied i.e., \code{ncol(B_time)}.}
\item{num_B_spacetime: }{The number of spatio-temporal basis functions supplied i.e., \code{ncol(B_spacetime)}.}
\item{num_B: }{The total number of basis functions supplied i.e., \code{ncol(cbind(B_space, B_time, B_spacetime))}.}
\item{logLik: }{The value of the PQL likelihood upon convergence.}
\item{betas: }{The estimated matrix of species-specific regression coefficients corresponding to the model matrix created. The number of rows in \code{betas} is equal to the number of species i.e., \code{ncol(y)}.}
\item{basis_effects_mat: }{The estimated matrix of species-specific regression coefficients corresponding to the combined matrix of basis functions. The number of rows in \code{basis_effects_mat} is equal to the number of species i.e., \code{ncol(y)}.}
\item{dispparam: }{The estimated vector of species-specific dispersion parameters, for distributions which require one. }
\item{powerparam: }{The estimated vector of species-specific power parameters, for distributions which require one. }
\item{zeroinfl_prob_intercept: }{The estimated vector of species-specific probabilities of zero-inflation, for distributions which require one. \emph{Note this is presented on the logit scale}, that is the model returns \eqn{log(\pi_j/(1-\pi_j))} where \eqn{\pi_j} is the probability of zero-inflation. This is the same as the intercept term of a logistic regression model for the probabilities of zero-inflation, hence the name. }
\item{linear_predictor: }{The estimated matrix of linear predictors. Note that for zero-inflated distributions, the mean of the non-zero-inflated component is modeled in CBFM, and the function returns the linear predictors corresponding to this non-zero-inflated component in the CBFM. }
\item{fitted: }{The estimated matrix of fitted mean values. Note that for zero-inflated distributions, while the mean of the non-zero-inflated component is modeled in CBFM, the fitted values are the \emph{actual expected mean values} i.e., it returns estimated values of \eqn{(1-\pi_j)*\mu_{ij}} where \eqn{\pi_j} is the species-specific probability of zero inflation and \eqn{\mu_{ij}} is the mean of the non-zero-inflated component.}
\item{Sigma_space/Loading_Sigma_space/nugget_Sigma_space: }{The estimated community-level covariance matrix/loadings/nugget effect associated with the spatial basis functions, if \code{B_space} is supplied.}
\item{G_space/Loading_G_space/nugget_G_space: }{The estimated baseline between species correlation matrix/loadings/nugget effect associated with the spatial basis functions, if \code{B_space} is supplied.}
\item{Sigma_time/Loading_Sigma_time/nugget_Sigma_time: }{The estimated community-level covariance matrix/loadings/nugget effect associated with the temporal basis functions, if \code{B_time} is supplied.}
\item{G_time/Loading_G_time/nugget_G_time: }{The estimated baseline between species correlation matrix/loadings/nugget effect associated with the temporal basis functions, if \code{B_time} is supplied.}
\item{Sigma_spacetime/Loading_Sigma_spacetime/nugget_Sigma_spacetime: }{The estimated community-level covariance matrix/loadings/nugget effect associated with the spatio-temporal basis functions, if \code{B_spacetime} is supplied.}
\item{G_spacetime/Loading_G_spacetime/nugget_G_spacetime: }{The estimated baseline between species correlation matrix/loadings/nugget effect associated with the spatio-temporal basis functions, if \code{B_spacetime} is supplied.}
\item{stderrors: }{The supplied argument for \code{stderrors} i.e., whether standard errors were calculated.}
\item{covar_components: }{If \code{stderrors = TRUE}, then a list containing with the following components:
\enumerate{
\item \code{topleft}, which is a matrix corresponding to the top-left block of the full Bayesian posterior covariance matrix. The top-left block specifically relates to the regression coefficients associated with the measured predictors i.e., the covariance matrix associated with \code{object$betas}, and the species-specific zero-inflated probabilities on the logit scale if the response distribution involved one;
\item \code{topright}, which is a matrix of the top-right block of the full Bayesian posterior covariance matrix. The top-right block specifically relates to the cross-covariance of the regression coefficients associated with the measured predictors (plus the species-specific zero-inflated probabilities on the logit scale) and the basis functions i.e., the cross-covariance matrix between \code{object$betas} and \code{object$basis_effects_mat};
\item \code{bottomright}, which is a matrix containing components of the bottom-right block of the full Bayesian posterior covariance matrix. The bottom-left block specifically relates to the regression coefficients associated with the basis functions i.e., the covariance matrix associated with \code{object$basis_effects_mat}.
}

Please use the \code{\link[=summary]{summary()}} function to obtain standard errors and confidence interval limits in a (slightly) more user-friendly form.}
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Fits CBFMs to spatio-temporal multivariate abundance data, where the basis functions are used to account for spatio-temporal correlation within and between species. Three types of basis functions can supplied and included in conjunction with each other: 1) spatial basis fnuctions; 2) temporal basis functions; 3) spatio-temporal basis functions. For the part of the mean model corresponding to the measured covariates, CBFM currently permits both parametric terms and/or smoothing terms, where the latter makes use are included in a similar manner to \code{\link[mgcv:gam]{mgcv::gam()}}. Estimation and inference for CBFM is based on a maximum penalized quasi-likelihood (PQL) estimation approach.
}
\details{
Community-level basis function models (CBFMs) are a class of spatio-temporal joint species distribution models for multivariate abundance data, which builds on the ideas of fixed rank kriging (FRK, Cressie and Johannesson, 2008; Zammit-Mangion and Cressie, 2017) and multivariate spatio-temporoal mixed models (Bradley et al., 2018) and adapts them specifically for multivariate abundance data in community ecology. CBFMs provide an alternative and not necessarily superior approach to the increasingly popular latent variable models (LVMs) approach for joint species distribution modeling, as available in a number of packages such as \code{\link[Hmsc:Hmsc-package]{Hmsc::Hmsc-package()}} (Tikhonov et al., 2020), \code{\link[gllvm:gllvm]{gllvm::gllvm()}} (Niku et al., 2019), and \code{boral} (Hui, 2016); see also Warton et al., (2015a,b), Thorson et al. (2016) and Ovaskainen and Abrego (2020) among others for introductions to the use of LVMs in community ecology.  The key difference between LVMs and CBFMs is that rather than using a small number of latent variables which are assumed to be random across observational units to induce spatio-temporal correlations within and between species, CBFMs use a larger number of spatially, temporal, and/or spatio-temporal basis functions that are specified \emph{a-priori} and remain fixed in the model. The randomness instead comes from species-specific regression coefficients related to these basis functions, which in turn induce spatio-temporal correlations within and between species.

In using a basis function approach, CBFMs can thus be considered both as a type of generalized additive model (GAM, Guisan et al., 2002; Wood, 2017) and a generalized linear mixed model (GLMM, Bolker et al., 2009; Brooks et al., 2017). This in turn means CBFMs can leverage from the plethora of techniques that have been already developed for such methods, with one notable benefit being that computationally, CBFMs tend to more efficient and scale better than many existing implementations of LVMs.
\subsection{Some more mathematical details}{

Turning to more mathematical details, for the purposes of the package the CBFM is characterized by the following mean regression model: for observational unit \eqn{i=1,\ldots,N} and species \eqn{j=1,\ldots,m}, we have

\deqn{g(\mu_{ij}) = \eta_{ij} = x_i^\top\beta_j + b_i^\top a_j,}

where \eqn{g(.)} is a known link function, \eqn{x_i} denotes a vector of predictors for unit i i.e., the i-th row from the created model matrix, \eqn{\beta_j} denotes the corresponding regression coefficients for species j, \eqn{b_i} denotes a vector of spatial and/or temporal basis functions for unit i , and \eqn{a_j} denotes the corresponding regression coefficients for species j.

In the function, the vector of predictors \eqn{x_i} is created based on the \code{formula_X} and \code{data} arguments. Note that smoothing terms are permitted in \code{formula_X}, and these can be included in the same way as in \code{\link[mgcv:gam.models]{mgcv::gam.models()}}. Selection of smoothing terms is also possible, using either shrinkage smoothers or null space penalization; please see \code{\link[mgcv:gam.selection]{mgcv::gam.selection()}} and \code{\link[mgcv:step.gam]{mgcv::step.gam()}} for more details.

Next, the vector basis functions \eqn{b_i} is formed from the \code{B_space}, \code{B_time} and \code{B_spacetime} arguments. At least one of these arguments must be supplied. As an example, suppose we wish to fit a CBFM with spatial and temporal basis functions which are included in an additive manner. Then only \code{B_space} and \code{B_time} should be supplied, in which case the mean regression model for the CBFM can be rewritten as:

\deqn{g(\mu_{ij}) = \eta_{ij} = x_i^\top\beta_j + b_{i,space}^\top a_{j,space} + b_{i,time}^\top a_{j,time},}

where \eqn{b_i = (b_{i,space}, b_{i,time})} and \eqn{a_j = (a_{j,space}, a_{j,time})}. If purely spatial or temporal multivariate abundance data is recorded, then one should only supply \code{B_space} and \code{B_time}, respectively, ahd the mean regression model is simplified accordingly.

As another example, suppose we wish to include spatio-temporal basis functions (which are formed from a tensor-product). Then only \code{B_spacetime} should be supplied, in which case the mean regression model for the CBFM can be rewritten as:

\deqn{g(\mu_{ij}) = \eta_{ij} = x_i^\top\beta_j + b_{i,spacetime}^\top a_{j,spacetime},}

where \eqn{b_i = b_{i,spacetime}} and \eqn{a_j = a_{j,spacetime}}. More details and recommendations on how to construct this basis functions (including the tensor-product mentioned above) are provided later on.

It is up to the practitioner as to what 'flavor' of CBFM that wish to fit, depending on interpretation and question of interests. For instance, with spatio-temporal multivariate abundance data, one may want the separate sets of spatial and temporal basis functions to be included in an additive manner (as seen above, which in analogous to an LVM where separate spatial LVs and temporal LVMs are added together), or have a single set of spatio-temporal basis functions formed from a tensor-product say (also as seen above, which in analogous to an LVM with a set of spatio-temporal LVs), or have a combination of the two where (say) the basis functions included in \code{B_space} and \code{B_time} are accounting for correlations on a course scale while the basis functions included in \code{B_spacetime} are accounting for resoltions on a fine scale. We refer the interested reader to Thorson et al., (2016) and Thorson (2019) for examples of similar kinds of constructs and flavors within the LVM framework.

Having said that, it is in principle possible to employ a more data-driven approach such as cross-validation to choose the 'flavor' of CBFM for a particular dataset, although this is not currently not explicitly implemented in the package. The same discourse also applies to choosing the number of basis functions to include (similar to choosing the number of latent variables in a LVM), although this is also strongly dependent more on the type of basis functions used.

\strong{Note:} For zero-inflated distributions, it is the mean of the non-zero inflated component that is modeled and \emph{not} the mean of the entire distribution.

In the CBFM, basis functions \eqn{b_i} are specified \emph{a-priori} and remain fixed throughout. Instead, it is the associated species-specific regression coefficients \eqn{a_j} which are assumed to be random. Specifically, in this package we assume follow a multivariate normal distribution as follows:

\deqn{(a_1,\ldots,a_m) \sim N(0, kronecker(G, \Sigma)),}

where \eqn{G} is a so-called baseline between-species correlation matrix, \eqn{\Sigma} is the community-level covariance matrix for the basis function regression coefficients, and \eqn{kronecker(\cdot)} is the Kroneckker product operator. When multiple sets of basis functions are included, then this carries over. For instance, in the example above involving a CBFM with spatial and temporal basis functions, with only \code{B_space} and \code{B_time} supplied, then we have

\deqn{(a_{1,space},\ldots,a_{m,space}) \sim N(0, kronecker(G_{space}, \Sigma_{space})),}
and
\deqn{(a_{1,time},\ldots,a_{m,time}) \sim N(0, kronecker(G_{time}, \Sigma_{time})).}

Furthermore, to reduce the number of parameters needed to be estimated in both the \eqn{G}'s and \eqn{\Sigma}'s, a rank-reduced structure is adopted in both (inspired and similar to that of LVMs). Specifically, we assume \eqn{G = \Lambda_{G}\Lambda_{G}^top + \kappa_G I_m} where \eqn{\Lambda_{G}} is an \eqn{m \times d_G} loading matrix and \eqn{\kappa_G > 0} is a nugget effect, with \eqn{I_m} being an identity matrix with dimenson \eqn{m}. The quantity \eqn{d_G << m} is tha rank, and similar to LVMs the larger the rank the more flexible this structure is at capturing the baseline-between species correlations (at the cost of more parameters). Similarly, we have \eqn{\Sigma = \Lambda_{\Sigma}\Lambda_{\Sigma}^top + \kappa_{\Sigma} I_{q}}, where \eqn{\Lambda_{\Sigma}} is an \eqn{q \times d_{\Sigma}} loading matrix, and \eqn{q} is the number of basis functions included in the model. When multiple sets of basis functions are included e.g., both \code{B_space} and \code{B_time}, then rank-reduced structures are used accordingly.

The ranks \eqn{d_G} and \eqn{d_{\Sigma}} should be smaller than the number of species and basis functions respecitvely included in the model, and generally speaking provided the rank/s is large enough then results should not depend much on their choice. The nugget effect is included to ensure that resulting rank-reduced forms of \eqn{G} and \eqn{\Sigma} remain positive definite. Moreover they have the interpretation of adjusting for the relative strength of correlation between species, say.
}

\subsection{Distributions}{

Currently the following response distributions are permitted (in alphabetal order):
\describe{
\item{\code{betalogitfam()}: }{Beta distribution using a logit link. The corresponding mean-variance relationship is given by \eqn{V = \mu(1-\mu)/(1+\phi)} where \eqn{\mu} denotes the mean and \eqn{\phi} is the dispersion parameter.}
\item{\code{binomial(link = "logit")}: }{Binomial distribution, noting only the logit link is permitted. The corresponding mean-variance relationship is given by \eqn{V = N_{trial}\mu(1-\mu)} where \eqn{\mu} denotes the mean and \eqn{N_{trial}} is the trial size.}
\item{\code{Gamma(link = "log")}: }{Gamma distribution, noting only the log link is permitted. The corresponding mean-variance relationship is given by \eqn{V = \phi\mu^2} where \eqn{\mu} denotes the mean and \eqn{\phi} is the dispersion parameter.}
\item{\code{gaussian(link = "identity")}: }{Gaussian or normal distribution, noting only the identity link is permitted. The corresponding mean-variance relationship is given by \eqn{V = \phi}, where \eqn{\phi} is the dispersion parameter.}
\item{\code{poisson(link = "log")}: }{Poisson distribution, noting only the log link is permitted. The corresponding mean-variance relationship is given by \eqn{V = \mu} where \eqn{\mu} denotes the mean.}
\item{\code{nb2()}: }{Negative binomial distribution, noting only the log link is permitted. The corresponding mean-variance relationship is given by \eqn{V = \mu + \phi\mu^2} where \eqn{\mu} denotes the mean and \eqn{\phi} is the dispersion parameter.}
\item{\code{tweedielogfam()}: }{Tweedie distribution, noting only the log link is permitted. The corresponding mean-variance relationship is given by \eqn{V = \phi\mu^{\rho}} where \eqn{\mu} denotes the mean, \eqn{\phi} is the dispersion parameter, and \eqn{\rho} is the power parameter.}
\item{\code{zipoisson()}: }{Zero-inflated Poisson distribution, noting only the log link for the Poisson part is permitted. This partial mass function of the distribution is given by \eqn{f(y) = \pi I(y=0) + (1-pi) f_{pois}(y)}, where \eqn{\pi} is the probability of being in the zero-inflation component, while \eqn{f_{pois}(y)} is the usual Poisson distribution. The mean of the Poisson distribution is modeled against covariates and basis functions, while the probability of zero-inflation is a single, species-specific quantity that is estimated.}
\item{\code{zinb2()}: }{Zero-inflated negative binomial distribution, noting only the log link for the negative binomial part is permitted. The partial mass function of the distribution is given by \eqn{f(y) = \pi I(y=0) + (1-pi) f_{NB}(y)}, where \eqn{\pi} is the probability of being in the zero-inflation component, while \eqn{f_{NB}(y)} is the usual negative binomial distribution. The mean of the negative binomial distribution is modeled against covariates and basis functions, while the probability of zero-inflation is a single, species-specific quantity that is estimated.}
}
}

\subsection{Constructing basis functions}{

The CBFM approach relies on the inclusion of the \emph{pre-specified} spatial, temporal, and/or spatio-temporal basis functions to account for spatio-temporal correlations within and between species (see Hefley et al., 2017, for a general overview of using basis functions to model autocorrelation in ecological data). Currently, the package does not provide default arguments to use for this, and this is deliberately the case as we wish to compel the practitioner to "work" and therefore think a bit harder on designing the right basis functions for use when CBFMs to their particular analysis.

At the same time, it would be remiss to at least provide some brief recommendations based on previous experience, and we do so below. Please also see the examples later on for some more concrete applications.
\describe{
\item{\code{B_space}: }{We have found that the multi-resolution thin-plate spline basis functions (Tzeng and Huang, 2018), as implemented in \code{\link[autoFRK:mrts]{autoFRK::mrts()}}, work fairly well here as spatial basis functions. They are simple to use and require the user to only supply the number of basis functions, which itself is tied to the resolution at which the practitioner wants to model their spatial correlations. For spatial multivariate abundance data we have usually found that 50 or less spatial basis functions of such type are required.

Another option for spatial basis functions is to use \code{\link[FRK:auto_basis]{FRK::auto_basis()}}, which produces basis functions that are sparse in design but consequently require \emph{many} more in number compared to the multi-resolution thin-plate splines mentioned above. This approach is more customizable however, with the choice of resolutions, basis function centers, and aperture among other choices; please see Zammit-Mangion and Cressie (2017) and Wilke et al. (2019) for more details.}
\item{\code{B_time}: }{Both of the approaches mentioned above for \code{B_space} can also be applied here, although with temporal basis functions we have generally found the approach implemented in \code{\link[FRK:auto_basis]{FRK::auto_basis()}} to work satisfactorily in many cases, given their customizability and sparsity (local support). The multi-resolution thin-plate spline basis functions approach, when applied solely in the 1-D temporal dimension, can produce long-term temporal trends that may be undesirable.}
\item{\code{B_spacetime}: }{A general and most parsimonious starting point for constructing spatio-temporal basis functions is to make use of a tensor-product form (analogous to \code{\link[mgcv:te]{mgcv::te()}}). That is, after constructing a set of spatial and a set of temporal basis functions, we can use the \code{\link[=tensorproduct]{tensorproduct()}} function to construct the tensor-product and include them \code{B_spacetime}.

It is recommended that both 'ingredient' basis functions used in the tensor-product are sparse in design to facilitate computation e.g., as implemented in \code{\link[FRK:auto_basis]{FRK::auto_basis()}}; see the \code{\link[FRK:FRK-package]{FRK::FRK-package()}} package as well as Wilke et al. (2019) for some examples. Also, we recommend you do not use these same 'ingredient' basis functions in the \code{B_space} and \code{B_time} arguments, as this may lead to overfitting. Put another way, and as hinted at previously, if \code{B_spacetime} is supplied at the same time as either \code{B_space} and/or \code{B_time} is supplied, then they should generally be constructed to act different resolutions of the spatio-temporal correlation.}
}
}

\subsection{A note on estimation and inference}{

As mentioned above, because CBFMs uses a basis function approach to model spatio-temporal correlations between and within species, then they can be thought of as a type of GAM. Similar to many implementation of GAMs then, this package uses a maximized penalized quasi-likelihood or PQL approach for estimation and inference (Breslow and Clayton, 1993; Wood, 2017), with baseline between-response correlation and community-level covariance matrices estimated by maximum Laplace approximated residual maximum likelihood (REML) estimation (Wood, 2011). Currently, the package itself makes use of both the machinery available in the \link{mgcv} package (Wood, 2017) as well as that of Template Model Builder (TMB, Kristensen et al., 2016).

Standard errors and resulting techniques like confidence intervals are based on the approximate large sample distribution of the regression coefficients, and use the so-called Bayesian posterior covariance matrix for the coefficients, similar to (but not as sophisticated as!) what is provided  \code{\link[mgcv:summary.gam]{mgcv::summary.gam()}}. Please note that all standard errors and thus inference are currently computed without considering uncertainty in estimation of covariance \eqn{\Sigma} and correlation matrices \eqn{G}. They can lead to standard errors that are potentially too small, so please keep this in mind.

Also, the current estimation approach does not provide uncertainty quantification of \eqn{\Sigma} and \eqn{G}, analogous to how the \link{mgcv} package (at least bu default) does not provide uncertainty estimates in the smoothing parameter. This is in line with the current main aims of this CBFM package, which are tailored more towards estimation and inference of regression coefficients and spatio-temporal prediction (in a relatively computationally efficient and scalable manner). Future versions of package may seek to rectify this, but for now apologies!
}
}
\section{Warning}{
CBFMs are designed for \emph{spatio-temporal} multivariate abundance data, such that you can sensibly construct basis functions from the space-time coordinate of each observational unit. Please do not use them for data that are \strong{not} spatially or temporally indexed. We recommend you fit standard LVMs in those scenarios, such that made available in \code{\link[gllvm:gllvm]{gllvm::gllvm()}}.

Not for some distributions it is not the mean of the entire distribution which is modeled. For example, in zero-inflated distributions it is the mean of the non-zero-inflated component that is modeled with the regression model described above.

Please note that all standard errors and thus inference are currently computed without considering uncertainty in estimation of covariance \eqn{\Sigma} and correlation matrices \eqn{G}, as well as the any dispersion/power paameters, analogous to \code{\link[mgcv:summary.gam]{mgcv::summary.gam()}}. This can lead to standard errors that are potentially too small, so please keep this in mind. Also, the current estimation approach does not provide uncertainty quantification of \eqn{\Sigma} and \eqn{G}. Indeed, the "strength" of the CBFM approach (especially with the current approach to estimation) is its competitive predictive performance relative to computation efficiency and scalability: estimates of \eqn{\Sigma} and \eqn{G} may not be overly reliable.
}

\examples{
\donttest{
library(autoFRK)
library(FRK)
library(MASS)
library(mvabund)
library(mvtnorm)
library(ROCR)
library(sp)
library(RandomFields)
library(tidyverse)

##------------------------------
## **Example 1a: Fitting a CBFM to spatial multivariate presence-absence data**
## simulated from a spatial latent variable model
## Please note the data generation process (thus) differs from CBFM.
##------------------------------
set.seed(2021)
num_sites <- 1000 # 500 (units) sites for training set + 500 sites for testing.
num_spp <- 50 # Number of species
num_X <- 4 # Number of regression slopes

spp_slopes <- matrix(runif(num_spp * num_X, -1, 1), nrow = num_spp)
spp_intercepts <- runif(num_spp, -2, 0)

# Simulate spatial coordinates and environmental covariate components
# We will use this information in later examples as well
xy <- data.frame(x = runif(num_sites, 0, 5), y = runif(num_sites, 0, 5))
X <- rmvnorm(num_sites, mean = rep(0,4)) 
colnames(X) <- c("temp", "depth", "chla", "O2")
dat <- data.frame(xy, X)
mm <- model.matrix(~ temp + depth + chla + O2 - 1, data = dat) \%>\% 
scale \%>\% 
as.matrix

# Simulate latent variable component
# We will use this information in later examples as well
true_lvs <- RFsimulate(model = RMexp(var=1, scale=2), 
x = xy$x, y = xy$y, n = 2)@data \%>\% 
as.matrix
spp_loadings <- matrix(runif(num_spp * 2, -1, 1), nrow = num_spp) 
set.seed(NULL)

# Simulate spatial multivariate abundance data (presence-absence)
# We will use this information in later examples as well
eta <- tcrossprod(cbind(1,mm), cbind(spp_intercepts,spp_slopes)) + 
tcrossprod(true_lvs, spp_loadings)
simy <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = plogis(eta)), nrow = num_sites)

# Form training and test sets
dat_train <- dat[1:500,]
dat_test <- dat[501:1000,]
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]
rm(X, mm, spp_loadings, true_lvs, xy, simy, dat)


# Fit stacked GLM as a baseline
fitstacked <- manyglm(simy_train ~ temp + depth + chla + O2, family = binomial(), data = dat_train)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# We will also use this basis functions in some later examples
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit CBFM 
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = binomial(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- predict(fitstacked, newdata = dat_test, type = "response")
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Tjur R-squared across species
tjurR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
m1 <- predictions_stacked[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_stacked[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
}),
cbfm = sapply(1:num_spp, function(j) { 
m1 <- predictions_cbfm[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_cbfm[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
})
)

boxplot(tjurR2, main = "Tjur-R2", names = c("Stacked GLM", "CBFM"))

ggplot(tjurR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Tjur-R2") +
theme_bw()

# AUC across species
aucs <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_stacked[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc")  
pred@y.values[[1]]
}),
cbfm = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_cbfm[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc") 
pred@y.values[[1]]
})
)

boxplot(aucs, main = "AUC", names = c("Stacked GLM", "CBFM"))

ggplot(aucs, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "AUC") +
theme_bw()



##------------------------------
## **Example 1b: Repeat Example 1a but illustrate the use of smoothing terms in CBFM**
## Since the true model only involves parametric terms, then we do not expect its performance
## to be as good as assuming the right form for the mean model.
## It is purely for illustration purposes. 
## Please note this will take a while to run...get a cup of tea and stretch your legs! 
##------------------------------
# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as Example 1a
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit CBFM 
tic <- proc.time()
fitcbfm_gam <- CBFM(y = simy_train, formula_X = ~ s(temp) + s(depth) + s(chla) + s(O2), 
data = dat_train, B_space = train_basisfunctions, family = binomial(), control = list(trace = 1))
toc <- proc.time()
toc-tic

summary(fitcbfm_gam) \%>\% 
str


# Calculate predictions onto test dataset
predictions_cbfm_gam <- predict(fitcbfm_gam, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Tjur R-squared across species
tjurR2$cbfm_gam = sapply(1:num_spp, function(j) { 
m1 <- predictions_cbfm_gam[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_cbfm_gam[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
})

boxplot(tjurR2, main = "Tjur-R2", names = c("Stacked GLM", "CBFM", "CBFM (GAM)"))

ggplot(tjurR2, aes(x = stacked, y = cbfm_gam)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (GAM)", main = "Tjur-R2") +
theme_bw()

# AUC across species
aucs$cbfm_gam <- sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_cbfm_gam[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc") 
pred@y.values[[1]]
})

boxplot(aucs, main = "AUC", names = c("Stacked GLM", "CBFM", "CBFM (GAM)"))

ggplot(aucs, aes(x = stacked, y = cbfm_gam)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (GAM)", main = "AUC") +
theme_bw()



##------------------------------
## **Example 1c: Repeat Example 1a but illustrate applications to Poisson count data**
##------------------------------
# Simulate spatial multivariate abundance data
simy <- matrix(rpois(num_sites * num_spp, lambda = exp(eta)), nrow = num_sites)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]


# Fit stacked GLM as a baseline
fitstacked <- manyglm(simy_train ~ temp + depth + chla + O2, family = "poisson", 
data = dat_train)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as examples above
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit Poisson CBFM 
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = poisson(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- predict(fitstacked, newdata = dat_test, type = "response")
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Pseudo R-squared across species
pseudoR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
out <- cor(predictions_stacked[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
}),
cbfm = sapply(1:num_spp, function(j) { 
out <- cor(predictions_cbfm[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
})
)

boxplot(pseudoR2, main = "Pseudo-R2", names = c("Stacked GLM", "CBFM"))

ggplot(pseudoR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Pseudo-R2") +
theme_bw()

# Predictive deviance across species (lower is better)
preddeviance <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
-2*sum(dpois(simy_test[,j], lambda = predictions_stacked[,j], log = TRUE))
}),
cbfm = sapply(1:num_spp, function(j) { 
-2*sum(dpois(simy_test[,j], lambda = predictions_cbfm[,j], log = TRUE))
})
)

boxplot(preddeviance, main = "Deviance", names = c("Stacked GLM", "CBFM"))

ggplot(preddeviance, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Deviance") +
theme_bw()


##------------------------------
## **Example 1d: Repeat Example 1a but illustrate applications to negative binomial count data** 
##------------------------------
# Simulate spatial multivariate abundance data
spp_dispersion <- runif(num_spp)
simy <- matrix(rnbinom(num_sites * num_spp, mu = exp(eta), 
size = matrix(1/spp_dispersion, nrow = num_sites, ncol = num_spp, byrow = TRUE)),
nrow = num_sites)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]

# Fit stacked GLM as a baseline
fitstacked <- manyglm(simy_train ~ temp + depth + chla + O2, family = "negative.binomial",
data = dat_train)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as examples above
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit negative binomial CBFM
# Please make sure you set up spatial basis functions for CBFM, we do so in Example 1a
# Please note the negative binomial distribution is not necessarily required for 
# overdispersed count data, since the latent variables can to some degree account for
# overdispersion. 
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = nb2(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- predict(fitstacked, newdata = dat_test, type = "response")
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Pseudo R-squared across species
pseudoR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
out <- cor(predictions_stacked[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
}),
cbfm = sapply(1:num_spp, function(j) { 
out <- cor(predictions_cbfm[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
})
)

boxplot(pseudoR2, main = "Pseudo-R2", names = c("Stacked GLM", "CBFM"))

ggplot(pseudoR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Pseudo-R2") +
theme_bw()

# Predictive deviance across species (lower is better)
preddeviance <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
-2*sum(dnbinom(simy_test[,j], mu = predictions_stacked[,j], size = 1/fitstacked$phi[j], 
log = TRUE))
}),
cbfm = sapply(1:num_spp, function(j) { 
-2*sum(dnbinom(simy_test[,j], mu = predictions_cbfm[,j], size = 1/fitcbfm$dispparam[j], 
log = TRUE))
})
)

boxplot(preddeviance, main = "Deviance", names = c("Stacked GLM", "CBFM"))

ggplot(preddeviance, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Deviance") +
theme_bw()


##------------------------------
## **Example 1e: Repeat Example 1a but illustrate applications to ZIP count data** 
##------------------------------
library(pscl)

# Probability of zero-inflation 
spp_zeroinfl_prob <- runif(num_spp, 0.1, 0.5) 

# Simulate spatial multivariate abundance data
component_ind <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = matrix(spp_zeroinfl_prob, num_sites, num_spp, byrow = TRUE)), num_sites, num_spp)
simy <- matrix(rpois(num_sites * num_spp, lambda = exp(eta) * (1-component_ind)), 
num_sites, num_spp)
rm(component_ind)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]


# Fit stacked ZIP regression models as a baseline
fitstacked <- NULL 
for(j in 1:num_spp) {
fitstacked[[j]] <- zeroinfl(resp ~ temp + depth + chla + O2 | 1, 
data = data.frame(resp = simy_train[,j], dat_train))
}


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as examples above
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit zero-inflated Poisson CBFM
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = zipoisson(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- sapply(1:num_spp, function(j) predict(fitstacked[[j]], 
newdata = dat_test, type = "response"))
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Pseudo R-squared across species
pseudoR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
out <- cor(predictions_stacked[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
}),
cbfm = sapply(1:num_spp, function(j) { 
out <- cor(predictions_cbfm[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
})
)

boxplot(pseudoR2, main = "Pseudo-R2", names = c("Stacked GLM", "CBFM"))

ggplot(pseudoR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Pseudo-R2") +
theme_bw()

# Predictive deviance across species (lower is better)
# Need to define density of zero-inflated Poisson distribution first (or get it from a package)
dlzipois <- function(y, lambda, p0) {
logp <- log(1-p0) + dpois(y, lambda = lambda, log=TRUE)
logp[y == 0] <- log(exp(logp[y == 0]) + p0) 
return(logp)
}
preddeviance <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
-2*sum(dlzipois(simy_test[,j], lambda = predictions_stacked[,j], 
p0 = plogis(fitstacked[[j]]$coefficients$zero)))
}),
cbfm = sapply(1:num_spp, function(j) { 
-2*sum(dlzipois(simy_test[,j], lambda = predictions_cbfm[,j], 
p0 = plogis(fitcbfm$zeroinfl_prob_intercept[j])))
})
)

boxplot(preddeviance, main = "Deviance", names = c("Stacked GLM", "CBFM"))

ggplot(preddeviance, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Deviance") +
theme_bw()



##------------------------------
## **Example 1f: Repeat Example 1a but illustrate applications to ZINB count data**
##------------------------------
# Probability of zero-inflation 
spp_zeroinfl_prob <- runif(num_spp, 0.1, 0.5) 
spp_dispersion <- runif(num_spp)

# Simulate spatial multivariate abundance data
# Note the deliberate "+2" on the linear predictor: This creates data that is a bit more 
# clearly overdispersed and zero-inflated...
component_ind <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = matrix(spp_zeroinfl_prob, num_sites, num_spp, byrow = TRUE)), num_sites, num_spp)
simy <- matrix(rnbinom(num_sites * num_spp, mu = exp(eta+2) * (1-component_ind),
size = matrix(1/spp_dispersion, nrow = num_sites, ncol = num_spp, byrow = TRUE)),
num_sites, num_spp)
rm(component_ind)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]


# Fit stacked ZIP regression models as a baseline
fitstacked <- NULL 
for(j in 1:num_spp) {
fitstacked[[j]] <- zeroinfl(resp ~ temp + depth + chla + O2 | 1, 
dist = "negbin", data = data.frame(resp = simy_train[,j], dat_train))
}


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as examples above
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit zero-inflated negative binomial CBFM
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = zinb2(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- sapply(1:num_spp, function(j) predict(fitstacked[[j]], 
newdata = dat_test, type = "response"))
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Pseudo R-squared across species
pseudoR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
out <- cor(predictions_stacked[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
}),
cbfm = sapply(1:num_spp, function(j) { 
out <- cor(predictions_cbfm[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
})
)

boxplot(pseudoR2, main = "Pseudo-R2", names = c("Stacked GLM", "CBFM"))

ggplot(pseudoR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Pseudo-R2") +
theme_bw()

# Predictive deviance across species (lower is better)
# Need to define density of zero-inflated Poisson distribution first (or get it from a package)
dlzinb <- function(y, lambda, p0, phi) {
logp <- log(1-p0) + dnbinom(y, mu = lambda, size = 1/phi, log=TRUE)
logp[y == 0] <- log(exp(logp[y == 0]) + p0) 
return(logp)
}
preddeviance <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
-2*sum(dlzinb(simy_test[,j], lambda = predictions_stacked[,j], 
p0 = plogis(fitstacked[[j]]$coefficients$zero),
phi = 1/fitstacked[[j]]$theta))
}),
cbfm = sapply(1:num_spp, function(j) { 
-2*sum(dlzinb(simy_test[,j], lambda = predictions_cbfm[,j], 
p0 = plogis(fitcbfm$zeroinfl_prob_intercept[j]),
phi = fitcbfm$dispparam[j]))
})
)

boxplot(preddeviance, main = "Deviance", names = c("Stacked GLM", "CBFM"))

ggplot(preddeviance, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Deviance") +
theme_bw()



##------------------------------
## **Example 1g Repeat Example 1a but illustrate applications to biomass**
##------------------------------
library(tweedie)
library(statmod)

spp_dispersion <- runif(num_spp, 0, 5)
simy <- matrix(rtweedie(num_sites * num_spp, mu = exp(eta), 
phi = matrix(spp_dispersion, nrow = num_sites, ncol = num_spp, byrow = TRUE),
power = 1.6),
nrow = num_sites)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]

# Fit stacked GLM as a baseline
fitstacked <- lapply(1:num_spp, function(j) {
# Note power parameter is assumed to be known for stacked model
glm(simy_train[,j] ~ temp + depth + chla + O2, 
family = tweedie(var.power = 1.6, link.power = 0), data = dat_train)
})


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
# This is the same set up as examples above
num_basisfunctions <- 25 # Number of spatial basis functions to use
# Training set basis functions
train_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_basisfunctions <- mrts(dat_train[,c("x","y")], num_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Fit Tweedie CBFM
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_basisfunctions, family = tweedielogfam(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Calculate predictions onto test dataset
predictions_stacked <- sapply(1:num_spp, function(j) {
predict(fitstacked[[j]], newdata = dat_test, type = "response")
})
predictions_cbfm <- predict(fitcbfm, newdata = dat_test, type = "response", 
new_B_space = test_basisfunctions)

# Evaluation predictions
# Pseudo R-squared across species
pseudoR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
out <- cor(predictions_stacked[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
}),
cbfm = sapply(1:num_spp, function(j) { 
out <- cor(predictions_cbfm[,j], simy_test[,j], method = "spearman")
out^2 * sign(out)     
})
)

boxplot(pseudoR2, main = "Pseudo-R2", names = c("Stacked GLM", "CBFM"))

ggplot(pseudoR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Pseudo-R2") +
theme_bw()

# Predictive deviance across species (lower is better)
preddeviance <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
-2*sum(log(dtweedie(simy_test[,j], mu = predictions_stacked[,j], 
phi = mean(fitstacked[[j]]$residuals^2), power = 1.6)))
}),
cbfm = sapply(1:num_spp, function(j) { 
-2*sum(log(dtweedie(simy_test[,j], mu = predictions_cbfm[,j], 
phi = fitcbfm$dispparam[j], power = fitcbfm$powerparam[j])))
})
)

boxplot(preddeviance, main = "Deviance", names = c("Stacked GLM", "CBFM"))

ggplot(preddeviance, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM", main = "Deviance") +
theme_bw()

rm(list = ls())



##------------------------------
## **Example 2a: Fitting a CBFM to multivariate spatial continuous data**
## with a data generation pulled from the Hmsc vignette (also spatial latent variable model)
## Please see Case 6 in
## <https://cran.r-project.org/web/packages/Hmsc/vignettes/vignette_5_performance.pdf>
##------------------------------
library(Hmsc)
library(devtools)

# The makedata function included in the vignette folder produces datasets 
# based on the Hmsc model
source_url("https://raw.githubusercontent.com/hmsc-r/HMSC/master/vignettes/makedata.R")

tmp = makedata(ns=50, ny=200, spatial=TRUE)
all.data=tmp[[1]]
all.parameters=tmp[[2]]

# Fit stacked GLM as a baseline
fitstacked <- manylm(all.data$Y ~ X.categorical + X.covariate, data = all.data$X.data)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
num_basisfunctions <- 20 # Number of spatial basis functions to use
basisfunctions <- mrts(all.data$xy, num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column

# Fit CBFM 
tic <- proc.time()
fitcbfm <- CBFM(y = all.data$Y, formula_X = all.data$X.formula, data = all.data$X.data, 
B_space = basisfunctions, family = gaussian(), control = list(trace = 1))
toc <- proc.time()
toc - tic

summary(fitcbfm) \%>\% 
str


# Evaluate in-sample performance (similar to what was done in the Hmsc vignette)
# with the = evaluateModelFit() function 
predictions_stacked <- fitstacked$fitted
predictions_cbfm <- fitcbfm$fitted 

num_spp <- ncol(all.data$Y)

# Root mean-squared error (RMSE)
RMSE <- data.frame(stacked = sapply(1:num_spp, function(j) {
sqrt(mean((all.data$Y[,j]-predictions_stacked[,j])^2))
}),
cbfm = sapply(1:num_spp, function(j) {
sqrt(mean((all.data$Y[,j]-predictions_cbfm[,j])^2))
})
)
boxplot(RMSE, main = "RMSE", names = c("Stacked GLM", "CBFM"))

pearsonR2 <- data.frame(stacked = sapply(1:num_spp, function(j) {
out <- cor(all.data$Y[,j], predictions_stacked[,j])
out^2 * sign(out)
}),
cbfm = sapply(1:num_spp, function(j) {
out <- cor(all.data$Y[,j],predictions_cbfm[,j])
out^2 * sign(out)
})
)
boxplot(pearsonR2, main = "Pearson R-squared", names = c("Stacked GLM", "CBFM"))

pearsonR2 <- data.frame(stacked = sapply(1:num_spp, function(j) {
out <- cor(all.data$Y[,j], predictions_stacked[,j])
out^2 * sign(out)
}),
cbfm = sapply(1:num_spp, function(j) {
out <- cor(all.data$Y[,j],predictions_cbfm[,j])
out^2 * sign(out)
})
)
boxplot(pearsonR2, main = "Pearson R-squared", names = c("Stacked GLM", "CBFM"))



##------------------------------
## **Example 2b: Repeat example 2a with presence-absence data**
## Similar to a combination of Cases 2 and 6 in
## <https://cran.r-project.org/web/packages/Hmsc/vignettes/vignette_5_performance.pdf>
##------------------------------
# Generate data
L1 = all.parameters$L
Y2 = 1*(L1 + matrix(rnorm(n = nrow(all.data$Y)*ncol(all.data$Y)), ncol = ncol(all.data$Y)) > 0)
all.data$Y = Y2


# Fit stacked GLM as a baseline
fitstacked <- manyglm(all.data$Y ~ X.categorical + X.covariate, data = all.data$X.data,
family = binomial())


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
num_basisfunctions <- 20 # Number of spatial basis functions to use
basisfunctions <- mrts(all.data$xy, num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column

# Fit CBFM 
# Note also that Hmsc generates and fits models assuming a probit link, 
# but CBFM uses a logit link
tic <- proc.time()
fitcbfm <- CBFM(y = all.data$Y, formula_X = all.data$X.formula, data = all.data$X.data, 
B_space = basisfunctions, family = binomial(), control = list(trace = 1))
toc <- proc.time()
toc - tic


# Evaluate in-sample performance (similar to what was done in the Hmsc vignette)
# with the = evaluateModelFit() function 
predictions_stacked <- fitstacked$fitted
predictions_cbfm <- fitcbfm$fitted 

num_spp <- ncol(all.data$Y)

# Root mean-squared error (RMSE)
RMSE <- data.frame(stacked = sapply(1:num_spp, function(j) {
sqrt(mean((all.data$Y[,j]-predictions_stacked[,j])^2))
}),
cbfm = sapply(1:num_spp, function(j) {
sqrt(mean((all.data$Y[,j]-predictions_cbfm[,j])^2))
})
)
boxplot(RMSE, main = "RMSE", names = c("Stacked GLM", "CBFM"))

# Tjur R-squared across species
tjurR2 <- data.frame(stacked = sapply(1:num_spp, function(j) { 
m1 <- predictions_stacked[which(all.data$Y[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_stacked[which(all.data$Y[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
}),
cbfm = sapply(1:num_spp, function(j) { 
m1 <- predictions_cbfm[which(all.data$Y[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_cbfm[which(all.data$Y[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
})
)
boxplot(tjurR2, main = "Tjur-R2", names = c("Stacked GLM", "CBFM"))

# AUC across species
aucs <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_stacked[,j], labels = all.data$Y[,j]) \%>\%
performance(measure = "auc")  
pred@y.values[[1]]
}),
cbfm = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_cbfm[,j], labels = all.data$Y[,j]) \%>\%
performance(measure = "auc") 
pred@y.values[[1]]
})
)
boxplot(aucs, main = "AUC", names = c("Stacked GLM", "CBFM"))

set.seed(NULL)
rm(list = ls())



##------------------------------
## **Example 3a: Fitting an additive CBFM to spatio-temporal multivariate presence-absence data**
## simulated from a spatio-temporal latent variable model
## Please note the data generation process (thus) differs from CBFM.
## Also, the additive CBFM might take a while to fit...grab a cup of tea or coffee!
##------------------------------
set.seed(2021)
num_sites <- 1000 # 500 (units) sites for training set + 500 sites for testing.
num_spp <- 50 # Number of species
num_X <- 4 # Number of regression slopes

spp_slopes <- matrix(runif(num_spp * num_X, -1, 1), nrow = num_spp)
spp_intercepts <- runif(num_spp, -2, 0)

# Simulate spatio-temporal coordinates and environmental covariate components
# Note we assume that each site is only visited once, but the code below can be adapted to 
# when the same sites are repeatedly visited
# We will also use this information in examples below
xy <- data.frame(x = runif(num_sites, 0, 5), y = runif(num_sites, 0, 5))
X <- rmvnorm(num_sites, mean = rep(0,4)) 
colnames(X) <- c("temp", "depth", "chla", "O2")
dat <- data.frame(xy, time = sort(runif(1000, 0, 10)) , X)
mm <- model.matrix(~ temp + depth + chla + O2 - 1, data = dat) \%>\% 
scale \%>\% 
as.matrix

# Simulate latent variable component
# We will also use this information in examples below
true_space_lvs <- RFsimulate(model = RMexp(var = 1, scale = 2), x = xy$x, y = xy$y, 
n = 2)@data \%>\% 
as.matrix
true_time_lvs <- RFsimulate(model = RMgauss(var = 1, scale = 1), x = dat$time, 
n = 2)@data \%>\% 
as.matrix
spp_space_loadings <- matrix(runif(num_spp * 2, -1, 1), nrow = num_spp) 
spp_time_loadings <- matrix(runif(num_spp * 2, -0.5, 0.5), nrow = num_spp) 

# Simulate spatial multivariate abundance data (presence-absence)
# We will also use this information in examples below
eta <- tcrossprod(cbind(1,mm), cbind(spp_intercepts,spp_slopes)) + 
tcrossprod(true_space_lvs, spp_space_loadings) +
tcrossprod(true_time_lvs, spp_time_loadings)
simy <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = plogis(eta)), nrow = num_sites)

# Form training and test sets
simy_train <- simy[1:500,]
simy_test <- simy[501:1000,]
dat_train <- dat[1:500,]
dat_test <- dat[501:1000,]
rm(X, eta, mm, spp_space_loadings, spp_time_loadings, true_space_lvs, true_time_lvs,
xy, simy)


# Fit stacked GLM as a baseline
fitstacked <- manyglm(simy_train ~ temp + depth + chla + O2, family = binomial(), data = dat_train)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
num_space_basisfunctions <- 20 # Number of spatial basis functions to use
# Training set basis functions
train_space_basisfunctions <- mrts(dat_train[,c("x","y")], num_space_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column
# Testing set basis functions
test_space_basisfunctions <- mrts(dat_train[,c("x","y")], num_space_basisfunctions) \%>\% 
predict(newx = dat_test[,c("x","y")]) \%>\% 
as.matrix \%>\%
{.[,-c(1)]} 

# Training and test temporal basis functions
num_time_basisfunctions <- 10 # Number of temporal basis functions to use
time_knots <- seq(0, 10, length = num_time_basisfunctions)
time_basisfunctions <- local_basis(manifold = real_line(), loc = as.matrix(time_knots),
scale = rep(2, length(time_knots)), type = "bisquare")
time_basisfunctions <- eval_basis(time_basisfunctions, s = as.matrix(dat$time)) 
train_time_basisfunctions <- time_basisfunctions[1:500,] 
test_time_basisfunctions <- time_basisfunctions[501:1000,] 
rm(time_basisfunctions, time_knots)

# Fit CBFM with Additive spatial and temporal basis functions 
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
fitcbfm_additive <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_space = train_space_basisfunctions, B_time = train_time_basisfunctions, family = binomial(), 
G_control = list(rank = c(5,5)), Sigma_control = list(rank = c(5,5)), control = list(trace = 1))
toc <- proc.time()
toc - tic

 
# Calculate predictions onto test dataset
predictions_stacked <- predict(fitstacked, newdata = dat_test, type = "response")
predictions_cbfm_additive <- predict(fitcbfm_additive, newdata = dat_test, type = "response", 
new_B_space = test_space_basisfunctions, new_B_time = test_time_basisfunctions)

# Evaluation predictions
# Tjur R-squared across species
tjurR2 <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
m1 <- predictions_stacked[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_stacked[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
}),
cbfm = sapply(1:num_spp, function(j) { 
m1 <- predictions_cbfm_additive[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_cbfm_additive[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
})
)

boxplot(tjurR2, main = "Tjur-R2", names = c("Stacked GLM", "CBFM (additive)"))

ggplot(tjurR2, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (additive)", main = "Tjur-R2") +
theme_bw()

# AUC across species
aucs <- data.frame(
stacked = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_stacked[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc")  
pred@y.values[[1]]
}),
cbfm = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_cbfm_additive[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc") 
pred@y.values[[1]]
})
)

boxplot(aucs, main = "AUC", names = c("Stacked GLM", "CBFM (additive)"))

ggplot(aucs, aes(x = stacked, y = cbfm)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (additive)", main = "AUC") +
theme_bw()


##------------------------------
## **Example 3b: Repeat Example 3a but with tensor product basis functions**
## Please note the data generation process (thus) differs from CBFM.
## To save some time, and for illustrative purposes, we wil use the fast method estimating
## the covariance matrices
# Nevertheless, please note this might take quite a while...grab some senbei or a melonpan!
##------------------------------
tic <- proc.time()
useformula <- ~ temp + depth + chla + O2
train_st_basisfunctions <- tensorproduct(train_space_basisfunctions, train_time_basisfunctions)
dim(train_st_basisfunctions)

fitcbfm_tensor <- CBFM(y = simy_train, formula_X = useformula, data = dat_train, 
B_spacetime = train_st_basisfunctions, family = binomial(), 
G_control = list(rank = 10, method = "simple"), 
Sigma_control = list(rank = 10, method = "simple"), control = list(trace = 1))
toc <- proc.time()
toc - tic


test_st_basisfunctions <- tensorproduct(test_space_basisfunctions, test_time_basisfunctions)
predictions_cbfm_tensor <- predict(fitcbfm_tensor, newdata = dat_test, type = "response", 
new_B_spacetime = test_st_basisfunctions)

# Tjur-R2 across species
tjurR2$cbfm_tensor = sapply(1:num_spp, function(j) { 
m1 <- predictions_cbfm_tensor[which(simy_test[,j] > 0),j] \%>\%
mean(na.rm = TRUE)
m0 <- predictions_cbfm_tensor[which(simy_test[,j] == 0),j] \%>\%
mean(na.rm = TRUE)
m1 - m0     
})

boxplot(tjurR2, main = "Tjur-R2", 
names = c("Stacked GLM", "CBFM (additive)", "CBFM (tensor)"))

ggplot(tjurR2, aes(x = stacked, y = cbfm_tensor)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (tensor)", main = "Tjur-R2") +
theme_bw()

# AUC across species
aucs$cbfm_tensor = sapply(1:num_spp, function(j) { 
pred <- prediction(predictions_cbfm_tensor[,j], labels = simy_test[,j]) \%>\%
performance(measure = "auc") 
pred@y.values[[1]]
})

boxplot(aucs, main = "AUC", 
names = c("Stacked GLM", "CBFM (additive)", "CBFM (tensor)"))

ggplot(aucs, aes(x = stacked, y = cbfm_tensor)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, linetype = 2) +
labs(x = "Stacked SDM", y = "CBFM (tensor)", main = "AUC") +
theme_bw()

# As one can see, the tensor product CBFM here performs a lot worse than the additive CBFM.
# This is partly not surprising given that we used a more approximate fitting method for 
# the tensor product CBFM but also because of the additive latent variables underlying the data
# generation process.

# Indeed, both the authors of this package have found that in practice, the additive CBFM 
# oftens tends to perform better than the tensor product CBFM for 
# spatio-temporal multivariate abundance data.
}

}
\references{
Bolker, B. M., Brooks, M. E., Clark, C. J., Geange, S. W., Poulsen, J. R., Stevens, M. H. H., and White, J. S. S. (2009). Generalized linear mixed models: a practical guide for ecology and evolution. Trends in Ecology & Evolution, 24, 127-135.

Bradley, J. R., Holan, S. H., and Wikle, C. K. (2018). Computationally efficient multivariate spatio-temporal models for high-dimensional count-valued data (with discussion). Bayesian Analysis, 13, 253-310.

Breslow, N. E., and Clayton, D. G. (1993). Approximate inference in generalized linear mixed models. Journal of the American statistical Association, 88, 9-25.

Brooks, M. E., Kristensen, K., Van Benthem, K. J., Magnusson, A., Berg, C. W., Nielsen, A., and Bolker, B. M. (2017). glmmTMB balances speed and flexibility among packages for zero-inflated generalized linear mixed modeling. The R journal, 9, 378-400.

Cressie, N., and Johannesson, G. (2008). Fixed rank kriging for very large spatial data sets. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 70, 209-226.

Guisan, A., Edwards Jr, T. C., and Hastie, T. (2002). Generalized linear and generalized additive models in studies of species distributions: setting the scene. Ecological modelling, 157, 89-100.

Hefley, T. J., Broms, K. M., Brost, B. M., Buderman, F. E., Kay, S. L., Scharf, H. R., and Hooten, M. B. (2017). The basis function approach for modeling autocorrelation in ecological data. Ecology, 98, 632-646.

Hui, F. K. C. (2016). boral-Bayesian ordination and regression analysis of multivariate abundance data in R. Methods in Ecology and Evolution, 7, 744-750.

Kristensen, K., Nielsen, A., Berg, C. W., Skaug, H., and Bell, B. M. (2016). TMB: Automatic Differentiation and Laplace Approximation. Journal of Statistical Software, 70, 1-21.

Niku, J., Hui, F. K.C., Taskinen, S., and Warton, D. I. (2019). gllvm: Fast analysis of multivariate abundance data with generalized linear latent variable models in R. Methods in Ecology and Evolution, 10, 2173-2182.

Ovaskainen, O., and Abrego, N. (2020). Joint species distribution modelling: with applications in R. Cambridge University Press.

Thorson, J. T., Ianelli, J. N., Larsen, E. A., Ries, L., Scheuerell, M. D., Szuwalski, C., and Zipkin, E. F. (2016). Joint dynamic species distribution models: a tool for community ordination and spatio-temporal monitoring. Global Ecology and Biogeography, 25, 1144-1158.

Thorson, J. T. (2019). Guidance for decisions using the Vector Autoregressive Spatio-Temporal (VAST) package in stock, ecosystem, habitat and climate assessments. Fisheries Research, 210, 143-161.

Tikhonov, G., Opedal, O. H., Abrego, N., Lehikoinen, A., de Jonge, M. M., Oksanen, J., and Ovaskainen, O. (2020). Joint species distribution modelling with the R-package Hmsc. Methods in ecology and evolution, 11, 442-447.

Tzeng, S., and Huang, H. C. (2018). Resolution adaptive fixed rank kriging. Technometrics, 60, 198-208.

Wikle, C. K., Zammit-Mangion, A., and Cressie, N. (2019). Spatio-temporal Statistics with R. CRC Press.

Warton, D. I., Blanchet, F. G., O'Hara, R. B., Ovaskainen, O., Taskinen, S., Walker, S. C., and Hui, F. K. C. (2015). So many variables: joint modeling in community ecology. Trends in Ecology and Evolution, 30, 766-779.

Warton, D. I., Blanchet, F. G., O'Hara, R., Ovaskainen, O., Taskinen, S., Walker, S. C., and Hui, F. K. C. (2016). Extending Joint Models in Community Ecology: A Response to Beissinger et al. Trends in ecology & evolution, 31, 737-738.

Wood, S. N. (2011). Fast stable restricted maximum likelihood and marginal likelihood estimation of semiparametric generalized linear models. Journal of the Royal Statistical Society: Series B (Statistical Methodology), 73, 3-36.

Wood, S. N. (2017). Generalized additive models: an introduction with R. CRC press.

Zammit-Mangion, A., and Cressie, N. (2017). FRK: An R package for spatial and spatio-temporal prediction with large datasets. arXiv preprint arXiv:1705.08105.
}
\seealso{
\code{\link[=fitted.values.CBFM]{fitted.values.CBFM()}} for extracting the fitted values from a CBFM fit, \code{\link[=plot.CBFM]{plot.CBFM()}} for basic residual diagnostics from a CBFM fit, \code{\link[=predict.CBFM]{predict.CBFM()}} for constructing predictions from a CBFM fit, \code{\link[=residuals.CBFM]{residuals.CBFM()}} for calculating residuals from a CBFM fi, \code{\link[=simulate]{simulate()}} for simulating spatio-temporal multivariate abundance data from a CBFM fit, \code{\link[=summary.CBFM]{summary.CBFM()}} for summaries including standard errors and confidence intervals, and \code{\link[=varpart]{varpart()}} for variance partitioning of a CBFM fit.
}
\author{
Francis K.C. Hui \href{mailto:fhui28@gmail.com}{fhui28@gmail.com}, Chris Haak
}
