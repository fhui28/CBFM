% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/residuals.CBFM.R
\name{residuals.CBFM}
\alias{residuals.CBFM}
\title{Extract residuals from a CBFM fit}
\usage{
\method{residuals}{CBFM}(object, type = "response", seed = NULL, ...)
}
\arguments{
\item{object}{An object of class "CBFM".}

\item{type}{The type of residuals which should be returned. Currently the options available are: "repose" (default), "pearson", "PIT", "dunnsmyth", and "partial". Can be abbreviated.}

\item{seed}{This can be used set the seed when constructing the PIT and Dunn-Smyth residuals, which for discrete responses involve some degree of jittering.}

\item{...}{Not used.}
}
\value{
A matrix of residuals.
}
\description{
\ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}

Calculate various types of residuals from a fitted \code{CBFM} object, including probability integral transform (PIT) residuals and Dunn-Smyth residuals.
}
\details{
Suppose that the fitted values from a CBFM fit are denoted by \eqn{\hat{\mu}_{ij}} for observational unit \eqn{i = 1,\ldots,N} and species \eqn{j=1,\ldots,m}. Then:

For \code{type = "response"}, this returns the raw residuals \eqn{y_{ij} - \hat{\mu}_{ij}}. Note for binomial responses what is returned is \eqn{y_{ij}/N_{trial,ij} - \hat{\mu}_{ij}} where \eqn{N_{trial,ij}} is the corresponding trial size and \eqn{\hat{\mu}_{ij}} is the fitted probability of "success".
For zero-inflated distributions, this returns  \eqn{y_{ij} - (1-\hat{\pi}_j)\hat{\mu}_{ij}} where \eqn{\hat{\pi}_j} is the estimated species-specific probability of zero-inflation and \eqn{\hat{\mu}_{ij}} is the estimated mean of the non-zero-inflated component.

For \code{type = "pearson"}, this returns the Pearson residuals, which are calculated by standardizing the raw residuals by the square root of their corresponding variance.

For \code{type = "PIT"}, this returns the probability integral transform residuals that are also used in \code{\link[DHARMa:simulateResiduals]{DHARMa::simulateResiduals()}} and \code{\link[mpcmp:rPIT]{mpcmp::rPIT()}}, among other packages. If the (estimated) model is correct, then these residuals should behave as random variables from a standard uniform distribution (Dunn and Smyth, 1996). Note there is a level of jitting used in producing the PIT residuals.

For \code{type = "dunnsmyth"}, this returns the Dunn-Smyth residuals that are also used in \code{\link[boral:ds.residuals]{boral::ds.residuals()}} and\code{\link[gllvm:residuals.gllvm]{gllvm::residuals.gllvm()}}, among other packages. If the (estimated) model is correct, then these residuals should behave as random variables from a standard normal distribution (Dunn and Smyth, 1996). Note there is a level of jitting used in producing the Dunn-Smyth residuals.
}
\examples{
\donttest{
library(autoFRK)
library(FRK)
library(MASS)
library(mvabund)
library(mvtnorm)
library(ROCR)
library(sp)
library(RandomFields)
library(tidyverse)

##------------------------------
## Example 1: Fitting a CBFM to spatial multivariate presence-absence data 
## simulated from a spatial latent variable model
## Please note the data generation process (thus) differs from CBFM.
##------------------------------
set.seed(2021)
num_sites <- 500 # 500 (units) sites 
num_spp <- 50 # Number of species
num_X <- 4 # Number of regression slopes

spp_slopes <- matrix(runif(num_spp * num_X, -1, 1), nrow = num_spp)
spp_intercepts <- runif(num_spp, -2, 0)

# Simulate spatial coordinates and environmental covariate components
xy <- data.frame(x = runif(num_sites, 0, 5), y = runif(num_sites, 0, 5))
X <- rmvnorm(num_sites, mean = rep(0,4)) 
colnames(X) <- c("temp", "depth", "chla", "O2")
dat <- data.frame(xy, X)
mm <- model.matrix(~ temp + depth + chla + O2 - 1, data = dat) \%>\% 
scale \%>\% 
as.matrix

# Simulate latent variable component
true_lvs <- RFsimulate(model = RMexp(var=1, scale=2), 
x = xy$x, y = xy$y, n = 2)@data \%>\% 
as.matrix
spp_loadings <- matrix(runif(num_spp * 2, -1, 1), nrow = num_spp) 
set.seed(NULL)

# Simulate spatial multivariate abundance data (presence-absence)
eta <- tcrossprod(cbind(1,mm), cbind(spp_intercepts,spp_slopes)) + 
tcrossprod(true_lvs, spp_loadings)
simy <- matrix(rbinom(num_sites * num_spp, size = 1, 
prob = binomial()$linkinv(eta)), nrow = num_sites)
rm(X, mm, spp_loadings, true_lvs, xy, eta)


# Set up spatial basis functions for CBFM -- Most practitioners will start here! 
num_basisfunctions <- 25 # Number of spatial basis functions to use
basisfunctions <- mrts(dat[,c("x","y")], num_basisfunctions) \%>\% 
as.matrix \%>\%
{.[,-(1)]} # Remove the first intercept column

# Fit CBFM 
useformula <- ~ temp + depth + chla + O2
fitcbfm <- CBFM(y = simy, formula_X = useformula, data = dat, 
B_space = basisfunctions, family = binomial(), control = list(trace = 1))

residuals(fitcbfm)

residuals(fitcbfm, type = "dunnsmyth")
}

}
\references{
Dunn, P. K., and Smyth, G. K. (1996). Randomized quantile residuals. Journal of Computational and Graphical Statistics, 5, 236-244.
}
\seealso{
\code{\link[=CBFM]{CBFM()}} for fitting CBFMs and \code{\link[=fitted.values.CBFM]{fitted.values.CBFM()}} for calculating fitted values from a CBFM fit.
}
\author{
Francis K.C. Hui \href{mailto:fhui28@gmail.com}{fhui28@gmail.com}, Chris Haak
}
